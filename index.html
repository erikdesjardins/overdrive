<html>
<head></head>
<body>
<input type="file"></input>
<div id="playing"></div>
<div><input id="preband" type="range" min="0" max="100" value="50">Preband (inverse bypass)</div>
<div><input id="color" type="range" min="0" max="22000" value="800">Color</div>
<div><input id="drive" type="range" min="0" max="100" value="50">Drive</div>
<div><input id="postcut" type="range" min="0" max="22000" value="3000">Postcut (lowpass)</div>
<script>
function Overdrive (context, opts) {
  this.input = context.createGain();
  this.output = context.createGain();

  // Internal AudioNodes
  this._bandpass = context.createBiquadFilter();
  this._bpWet = context.createGain();
  this._bpDry = context.createGain();
  this._ws = context.createWaveShaper();
  this._lowpass = context.createBiquadFilter();

  // AudioNode graph routing
  this.input.connect(this._bandpass);
  this._bandpass.connect(this._bpWet);
  this._bandpass.connect(this._bpDry);
  this._bpWet.connect(this._ws);
  this._ws.connect(this._lowpass);
  this._lowpass.connect(this.output);
  this._bpDry.connect(this.output); // note: this has been modified
  // originally, both bpWet and bpDry passed through exactly the same path, so the preband option did nothing
  // now, bpDry bypasses the waveshaper and lowpass postcut filter, which is what I think it was supposed to be

  // Defaults
  var p = this.meta.params;
  opts = opts || {};
  this._bandpass.frequency.value  = opts.color        || p.color.defaultValue;
  this._bpWet.gain.value          = opts.preBand      || p.preBand.defaultValue;
  this._lowpass.frequency.value   = opts.postCut      || p.postCut.defaultValue;
  this.drive                      = opts.drive        || p.drive.defaultValue;

  // Inverted preBand value
  this._bpDry.gain.value = opts.preBand
    ? 1 - opts.preBand
    : 1 - p.preBand.defaultValue;
}

Overdrive.prototype = Object.create(null, {

  /**
   * AudioNode prototype `connect` method.
   *
   * @param {AudioNode} dest
   */

  connect: {
    value: function (dest) {
      this.output.connect( dest.input ? dest.input : dest );
    }
  },

  /**
   * AudioNode prototype `disconnect` method.
   */

  disconnect: {
    value: function () {
      this.output.disconnect();
    }
  },

  /**
   * Module parameter metadata.
   */

  meta: {
    value: {
      name: "Overdrive",
      params: {
        preBand: {
          min: 0,
          max: 1.0,
          defaultValue: 0.5,
          type: "float"
        },
        color: {
          min: 0,
          max: 22050,
          defaultValue: 800,
          type: "float"
        },
        drive: {
          min: 0.0,
          max: 1.0,
          defaultValue: 0.5,
          type: "float"
        },
        postCut: {
          min: 0,
          max: 22050,
          defaultValue: 3000,
          type: "float"
        }
      }
    }
  },

  /**
   * Public parameters
   */

  preBand: {
    enumerable: true,
    get: function () { return this._bpWet.gain.value; },
    set: function (value) {
      this._bpWet.gain.setValueAtTime(value, 0);
      this._bpDry.gain.setValueAtTime(1 - value, 0);
    }
  },

  color: {
    enumerable: true,
    get: function () { return this._bandpass.frequency.value; },
    set: function (value) {
      this._bandpass.frequency.setValueAtTime(value, 0);
    }
  },

  drive: {
    enumerable: true,
    get: function () { return this._drive; },
    set: function (value) {
      var k = value * 100
        , n = 22050
        , curve = new Float32Array(n)
        , deg = Math.PI / 180;

      this._drive = value;
      for (var i = 0; i < n; i++) {
        var x = i * 2 / n - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
      this._ws.curve = curve;
    }
  },

  postCut: {
    enumerable: true,
    get: function () { return this._lowpass.frequency.value; },
    set: function (value) {
      this._lowpass.frequency.setValueAtTime(value, 0);
    }
  }

});
</script>
<script>
var overdrive, source;

document.getElementById('preband').addEventListener('input', e => overdrive.preBand = e.target.value / 100);
document.getElementById('color').addEventListener('input', e => overdrive.color = +e.target.value);
document.getElementById('drive').addEventListener('input', e => overdrive.drive = e.target.value / 100);
document.getElementById('postcut').addEventListener('input', e => overdrive.postCut = +e.target.value);

document.querySelector('input').addEventListener('change', function(e) {
	var context = new AudioContext();
	overdrive = new Overdrive(context);

	var file = e.target.files[0];
	if (!file) return;
	var reader = new FileReader();
	reader.onload = function() {
		context.decodeAudioData(reader.result, function(audioBuffer) {
			if (source) source.stop(0);

			document.getElementById('playing').textContent = file.name;
			document.querySelector('input').value = null;

			source = context.createBufferSource();
			source.buffer = audioBuffer;
			source.connect(overdrive.input);
			overdrive.connect(context.destination);
			source.start(0);
		});
	}
	reader.readAsArrayBuffer(file);
});
</script>
</body>
</html>
